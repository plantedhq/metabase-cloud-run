# This workflow will build a docker container, publish it to
# Google Container Registry, and deploy it on Cloud Run when
# a commit is pushed on master branch.
#

name: Build & Deploy
on:
  push:
    branches:
      - main

env:
  REGISTRY_HOSTNAME: europe-west3-docker.pkg.dev/artifacts-428913
  REGISTRY_FOLDER: tools
  REGISTRY_IMAGE_NAME: ${{ github.event.repository.name }}
  GCP_PROJECT: tools-431609
  CLOUD_RUN_SERVICE_NAME: ${{ github.event.repository.name }}
  CLOUD_RUN_REGION: europe-north1
  CLOUD_RUN_CPU: 1
  CLOUD_RUN_MEMORY: 4Gi
  CLOUD_RUN_TIMEOUT: 120s
  CLOUD_RUN_MAX_INSTANCES: 1
  CLOUD_RUN_CONCURRENCY: 250

jobs:
  deploy:
    name: Build & Deploy
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout mono repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Authenticate with Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: "${{ secrets.GCP_CREDENTIALS }}"

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: "Build Container Image"
        run: docker build . -t $REGISTRY_IMAGE_NAME:${{ github.sha }}

      - name: "Tag Images for Registry"
        run: |
          docker tag $REGISTRY_IMAGE_NAME:${{ github.sha }} $REGISTRY_HOSTNAME/$REGISTRY_FOLDER/$REGISTRY_IMAGE_NAME:${{ github.sha }}
          docker tag $REGISTRY_IMAGE_NAME:${{ github.sha }} $REGISTRY_HOSTNAME/$REGISTRY_FOLDER/$REGISTRY_IMAGE_NAME:latest

      - name: "Publish Image to Container Registry"
        run: |
          docker push $REGISTRY_HOSTNAME/$REGISTRY_FOLDER/$REGISTRY_IMAGE_NAME:${{ github.sha }}
          docker push $REGISTRY_HOSTNAME/$REGISTRY_FOLDER/$REGISTRY_IMAGE_NAME:latest

      - name: "Deploy Image on Cloud Run"
        run: |
          gcloud run deploy $CLOUD_RUN_SERVICE_NAME \
            --project $GCP_PROJECT \
            --image $REGISTRY_HOSTNAME/$REGISTRY_FOLDER/$REGISTRY_IMAGE_NAME:latest \
            --region $CLOUD_RUN_REGION \
            --cpu $CLOUD_RUN_CPU \
            --memory $CLOUD_RUN_MEMORY \
            --timeout $CLOUD_RUN_TIMEOUT \
            --max-instances $CLOUD_RUN_MAX_INSTANCES \
            --concurrency $CLOUD_RUN_CONCURRENCY \
            --platform managed \
            --allow-unauthenticated \
            --port 3000 \
            --set-env-vars="JAVA_OPTS=-Xmx4096m" \
            --set-env-vars="MB_DB_TYPE=$MB_DB_TYPE" \
            --set-env-vars="MB_DB_HOST=$MB_DB_HOST" \
            --set-env-vars="MB_DB_PORT=$MB_DB_PORT" \
            --set-env-vars="MB_DB_DBNAME=$MB_DB_DBNAME" \
            --set-env-vars="MB_DB_USER=$MB_DB_USER" \
            --set-env-vars="MB_DB_PASS=$MB_DB_PASS" \

      - name: "Create Keep Alive"
        run: |
          gcloud scheduler jobs delete metabase-keep-alive \
            --project $GCP_PROJECT \
            --quiet || true
          gcloud scheduler jobs create http metabase-keep-alive \
            --project $GCP_PROJECT \
            --schedule="*/5 * * * *" \
            --http-method="get" \
            --uri="$MB_HOST"

      - name: "Check Container Ready"
        timeout-minutes: 10
        run: |
          while [ "$(curl $MB_HOST/api/health)" != "{\"status\":\"ok\"}" ]; \
            do curl -s -o /dev/null $MB_HOST; \
            sleep 3; \
            done
